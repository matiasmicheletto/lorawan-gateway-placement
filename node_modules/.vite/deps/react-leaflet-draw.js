import {
  useLeafletContext
} from "./chunk-RGMPFEZM.js";
import {
  require_leaflet_draw
} from "./chunk-U4MJFLCD.js";
import {
  require_prop_types
} from "./chunk-WX4KK3LC.js";
import {
  require_leaflet_src
} from "./chunk-HDFVGKDO.js";
import "./chunk-3GS3N7PG.js";
import {
  require_react
} from "./chunk-LL6ON2IQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/react-leaflet-draw/dist/esm/EditControl.js
var import_prop_types = __toESM(require_prop_types());
var import_leaflet_draw = __toESM(require_leaflet_draw());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_react = __toESM(require_react());
var import_leaflet = __toESM(require_leaflet_src());
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var eventHandlers = {
  onEdited: "draw:edited",
  onDrawStart: "draw:drawstart",
  onDrawStop: "draw:drawstop",
  onDrawVertex: "draw:drawvertex",
  onEditStart: "draw:editstart",
  onEditMove: "draw:editmove",
  onEditResize: "draw:editresize",
  onEditVertex: "draw:editvertex",
  onEditStop: "draw:editstop",
  onDeleted: "draw:deleted",
  onDeleteStart: "draw:deletestart",
  onDeleteStop: "draw:deletestop"
};
function EditControl(props) {
  var context = useLeafletContext();
  var drawRef = (0, import_react.useRef)();
  var propsRef = (0, import_react.useRef)(props);
  var onDrawCreate = function onDrawCreate2(e) {
    var onCreated = props.onCreated;
    var container = context.layerContainer || context.map;
    container.addLayer(e.layer);
    onCreated && onCreated(e);
  };
  import_react.default.useEffect(function() {
    var map = context.map;
    var onMounted = props.onMounted;
    for (var key in eventHandlers) {
      map.on(eventHandlers[key], function(evt) {
        var handlers = Object.keys(eventHandlers).filter(function(handler2) {
          return eventHandlers[handler2] === evt.type;
        });
        if (handlers.length === 1) {
          var handler = handlers[0];
          props[handler] && props[handler](evt);
        }
      });
    }
    map.on(import_leaflet.default.Draw.Event.CREATED, onDrawCreate);
    drawRef.current = createDrawElement(props, context);
    map.addControl(drawRef.current);
    onMounted && onMounted(drawRef.current);
    return function() {
      map.off(import_leaflet.default.Draw.Event.CREATED, onDrawCreate);
      for (var _key in eventHandlers) {
        if (props[_key]) {
          map.off(eventHandlers[_key], props[_key]);
        }
      }
      drawRef.current.remove(map);
    };
  }, []);
  import_react.default.useEffect(function() {
    if ((0, import_fast_deep_equal.default)(props.draw, propsRef.current.draw) && (0, import_fast_deep_equal.default)(props.edit, propsRef.current.edit) && props.position === propsRef.current.position) {
      return;
    }
    var map = context.map;
    drawRef.current.remove(map);
    drawRef.current = createDrawElement(props, context);
    drawRef.current.addTo(map);
    var onMounted = props.onMounted;
    onMounted && onMounted(drawRef.current);
    return function() {
      drawRef.current.remove(map);
    };
  }, [props.draw, props.edit, props.position]);
  return null;
}
function createDrawElement(props, context) {
  var layerContainer = context.layerContainer;
  var draw = props.draw, edit = props.edit, position = props.position;
  var options = {
    edit: _objectSpread(_objectSpread({}, edit), {}, {
      featureGroup: layerContainer
    })
  };
  if (draw) {
    options.draw = _objectSpread({}, draw);
  }
  if (position) {
    options.position = position;
  }
  return new import_leaflet.Control.Draw(options);
}
EditControl.propTypes = _objectSpread(_objectSpread({}, Object.keys(eventHandlers).reduce(function(acc, val) {
  acc[val] = import_prop_types.PropTypes.func;
  return acc;
}, {})), {}, {
  onCreated: import_prop_types.PropTypes.func,
  onMounted: import_prop_types.PropTypes.func,
  draw: import_prop_types.PropTypes.shape({
    polyline: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    polygon: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    rectangle: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    circle: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    marker: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool])
  }),
  edit: import_prop_types.PropTypes.shape({
    edit: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    remove: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    poly: import_prop_types.PropTypes.oneOfType([import_prop_types.PropTypes.object, import_prop_types.PropTypes.bool]),
    allowIntersection: import_prop_types.PropTypes.bool
  }),
  position: import_prop_types.PropTypes.oneOf(["topright", "topleft", "bottomright", "bottomleft"]),
  leaflet: import_prop_types.PropTypes.shape({
    map: import_prop_types.PropTypes.instanceOf(import_leaflet.Map),
    layerContainer: import_prop_types.PropTypes.shape({
      addLayer: import_prop_types.PropTypes.func.isRequired,
      removeLayer: import_prop_types.PropTypes.func.isRequired
    })
  })
});
var EditControl_default = EditControl;
export {
  EditControl_default as EditControl
};
//# sourceMappingURL=react-leaflet-draw.js.map
